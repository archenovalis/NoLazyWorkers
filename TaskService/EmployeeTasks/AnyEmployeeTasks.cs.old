using ScheduleOne.Employees;
using static NoLazyWorkers.Employees.Extensions;
using ScheduleOne.Property;
using NoLazyWorkers.Employees;
using Unity.Burst;
using static NoLazyWorkers.TaskService.Extensions;
using Unity.Collections;
using static NoLazyWorkers.CacheManager.Utilities;
using static NoLazyWorkers.Movement.Utilities;
using ScheduleOne.ItemFramework;
using ScheduleOne.Management;
using FishNet;
using static NoLazyWorkers.Movement.Extensions;
using static NoLazyWorkers.TaskService.TaskRegistry;
using UnityEngine;
using System.Diagnostics;
using static NoLazyWorkers.Debug;

namespace NoLazyWorkers.TaskService.EmployeeTasks
{
  public static class AnyEmployeeTasks
  {
    public static List<ITaskDefinition> Register()
    {
      return new List<ITaskDefinition>
            {
                new DeliverInventoryTaskDef()
            };
    }

    /// <summary>
    /// Defines the DeliverInventory task, which is employee-initiated and delivers items from inventory to storage.
    /// </summary>
    public class DeliverInventoryTaskDef : ITaskDefinition
    {
      public TaskName Type => TaskName.DeliverInventory;
      public int Priority => 40;
      public TaskEmployeeType EmployeeType => TaskEmployeeType.Any;
      public bool RequiresPickup => false;
      public bool RequiresDropoff => true;
      public TransitTypes PickupType => TransitTypes.Inventory;
      public TransitTypes DropoffType => TransitTypes.PlaceableStorageEntity;
      public IEntitySelector EntitySelector { get; } = new EmployeeEntitySelector();
      public ITaskValidator Validator { get; } = new DeliverInventoryValidator();
      public ITaskExecutor Executor { get; } = new DeliverInventoryExecutor();
    }

    /// <summary>
    /// Selects employee entities for task validation.
    /// </summary>
    public class EmployeeEntitySelector : IEntitySelector
    {
      public NativeList<Guid> SelectEntities(Property property, Allocator allocator)
      {
        var entities = new NativeList<Guid>(allocator);
        foreach (var employee in property.Employees)
          entities.Add(employee.GUID);
        Log(Level.Verbose, $"Selected {entities.Length} employee entities for property {property.name}", Category.AnyEmployee);
        return entities;
      }
    }

    /// <summary>
    /// Validates DeliverInventory tasks using Burst compilation with batch processing.
    /// </summary>
    [BurstCompile]
    public class DeliverInventoryValidator : ITaskValidator
    {
      public void Validate(ITaskDefinition definition, Guid guid, TaskValidatorContext context, Property property, NativeList<TaskDescriptor> validTasks)
      {
        var employee = property.Employees.FirstOrDefault(e => e.GUID == guid);
        if (employee == null)
        {
          Log(Level.Warning, $"DeliverInventoryValidator: No employee found for GUID {guid}", Category.AnyEmployee);
          return;
        }

        const int BATCH_SIZE = 4;
        var slots = employee.Inventory.ItemSlots.ToArray();
        for (int i = 0; i < slots.Length; i += BATCH_SIZE)
        {
          var batch = slots.Skip(i).Take(BATCH_SIZE);
          foreach (var slot in batch)
          {
            if (slot?.ItemInstance == null || slot.Quantity <= 0 || slot.IsLocked || IsItemTimedOut(property, slot.ItemInstance))
              continue;

            var destination = FindStorageForDelivery(employee, slot.ItemInstance, true);
            if (destination == null)
            {
              Log(Level.Verbose, $"DeliverInventoryValidator: No destination for item {slot.ItemInstance.ID} for employee {employee.fullName}", Category.AnyEmployee);
              continue;
            }

            var deliverySlots = destination.InputSlots
                .Where(s => s.ItemInstance == null || slot.ItemInstance.AdvCanStackWith(s.ItemInstance))
                .Take(3)
                .ToList();
            if (deliverySlots.Count == 0)
            {
              Log(Level.Verbose, $"DeliverInventoryValidator: No valid delivery slots for item {slot.ItemInstance.ID}", Category.AnyEmployee);
              continue;
            }

            var slotKey = new SlotKey(destination.GUID, deliverySlots[0].SlotIndex);
            if (context.ReservedSlots.ContainsKey(slotKey))
            {
              Log(Level.Verbose, $"DeliverInventoryValidator: Slot {slotKey} already reserved", Category.AnyEmployee);
              continue;
            }

            var task = TaskDescriptor.Create(
                guid,
                definition.Type,
                definition.EmployeeType,
                definition.Priority,
                context.AssignedPropertyName.ToString(),
                new ItemKey(slot.ItemInstance),
                slot.Quantity,
                definition.PickupType,
                Guid.Empty,
                new[] { slot.SlotIndex },
                definition.DropoffType,
                destination.GUID,
                deliverySlots.Select(s => s.SlotIndex).ToArray(),
                context.CurrentTime,
                employee.GUID,
                isFollowUpValidation: true
            );

            validTasks.Add(task);
            context.ReservedSlots.Add(slotKey, new SlotReservation { TaskId = task.TaskId, Timestamp = context.CurrentTime });
            Log(Level.Info, $"DeliverInventoryValidator: Created task {task.TaskId} for item {slot.ItemInstance.ID} to {destination.GUID}", Category.AnyEmployee);
          }
        }
      }
    }

    /// <summary>
    /// Executes DeliverInventory tasks asynchronously with retries and performance monitoring.
    /// </summary>
    public class DeliverInventoryExecutor : ITaskExecutor
    {
      public async Task ExecuteAsync(Employee employee, EmployeeInfo state, TaskDescriptor task)
      {
        var stopwatch = Stopwatch.StartNew();
        Log(Level.Info, $"DeliverInventoryExecutor: Starting task {task.TaskId} for {employee.fullName}", Category.AnyEmployee);
        try
        {
          if (!await TaskValidationService.ReValidateTaskAsync(employee, state, task))
          {
            Log(Level.Warning, $"DeliverInventoryExecutor: Task {task.TaskId} failed revalidation for {employee.fullName}", Category.AnyEmployee);
            return;
          }

          state.State.TaskContext = new TaskContext { Task = task };
          var routes = await Utilities.BuildTransferRoutesAsync(employee, task, batchSize: 2);
          if (!routes.Any())
          {
            Log(Level.Info, $"DeliverInventoryExecutor: No valid routes for task {task.TaskId}", Category.AnyEmployee);
            return;
          }

          int retries = 3;
          bool success = false;
          while (retries > 0 && !success)
          {
            var result = await TransitAsync(employee, state, task, routes.Select(r => r.Request).ToList());
            success = result.Success;
            if (!success)
            {
              Log(Level.Warning, $"DeliverInventoryExecutor: Retry {4 - retries} for task {task.TaskId}: {result.Error}", Category.AnyEmployee);
              retries--;
              await Utilities.DelayAsync(1f); // Backoff
            }
          }

          if (success)
          {
            await TaskRegistry.Get(task.Type).EnqueueFollowUpTasksAsync(employee, task);
            Log(Level.Info, $"DeliverInventoryExecutor: Successfully executed task {task.TaskId} for {employee.fullName}", Category.AnyEmployee);
            Utilities.LogExecutionTime(task.TaskId.ToString(), stopwatch.ElapsedMilliseconds);
          }
          else
          {
            Log(Level.Error, $"DeliverInventoryExecutor: Movement failed for task {task.TaskId} after retries", Category.AnyEmployee);
          }

          await state.AdvBehaviour.ExecuteTask();
        }
        catch (Exception ex)
        {
          Log(Level.Error, $"DeliverInventoryExecutor: Exception for task {task.TaskId}, employee {employee.fullName} - {ex}", Category.AnyEmployee);
        }
        finally
        {
          state.State.TaskContext?.Cleanup(employee);
          await state.AdvBehaviour.Disable();
          stopwatch.Stop();
          Utilities.LogExecutionTime(task.TaskId.ToString(), stopwatch.ElapsedMilliseconds);
          Log(Level.Info, $"DeliverInventoryExecutor: Completed task {task.TaskId} for {employee.fullName} in {stopwatch.ElapsedMilliseconds}ms", Category.AnyEmployee);
        }
      }
    }
  }
}